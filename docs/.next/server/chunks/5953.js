"use strict";exports.id=5953,exports.ids=[5953],exports.modules={65953:(e,t,n)=>{n.r(t),n.d(t,{default:()=>a});let a='---\ntitle: "Writing a Generic Fuzzy Search Algorithm in Swift"\nheadline: "Writing a Generic Fuzzy Search Algorithm in Swift"\nsubhead: Fuzzy searching finds matches even if there are spelling mistakes or slight variations in the search terms. It helps improve search accuracy by understanding what the user is likely looking for.\ndescription: Fuzzy searching finds matches even if there are spelling mistakes or slight variations in the search terms. It helps improve search accuracy by understanding what the user is likely looking for.\ndate: 2024-02-17\ncategory: insights\nauthor: tom-ludwig\nimage: https://github.com/activcoding/codeedit.app/assets/806104/e4db5b6a-0214-4cc7-8019-8354f37851aa\n---\n\n<img class="full-width ratio-21-9" alt="Search Field" src="https://github.com/activcoding/codeedit.app/assets/806104/e4db5b6a-0214-4cc7-8019-8354f37851aa">\n\n## What is fuzzy search?\n\nA fuzzy search algorithm is designed to find approximate matches for a given search query, rather than requiring an exact match. It takes into account the similarity between the search query and the data being searched, assigning scores to each potential match based on their resemblance. This allows the algorithm to return relevant results even when there are minor discrepancies or typos in the search input.\n\nLet\'s say you have a list of products, and a user is looking for a "Cozy Sweater." With a fuzzy search algorithm: If they type "Czy Swetr," the fuzzy search considers the similarity and still returns the "Cozy Sweater."\n\n## Different Algorithms\n\nThere are many algorithms out there providing fuzzy search capabilities, some of which you may have encountered. \nThese include the well-known **Levenshtein Distance**, the **Jaro-Winkler** Distance, **N-Gram** and the **Hamming \nDistance** Algorithm. Additionally, for those in pursuit of speed, two notable options are the **BK Tree** and **Bitmap \nAlgorithm**. It\'s worth noting that the most efficient and fastest fuzzy search algorithms often include keeping an \nindex of the data, most likely in the form of a trie.\n\nIn our example, we use an algorithm that emphasises matching prefixes and will provide a similarity score. The algorithm is fairly fast and easy to understand.\n\n## Putting search algorithms into practice\n\nLet\'s start by setting everything up.\n\nGo ahead and create a file called `Models`. As the name implies, this is where we define our data models.\nThe first one represents a search result:\n\n```swift\nstruct FuzzySearchMatchResult {\n    let weight: Int\n    let matchedParts: [NSRange]\n}\n```\n\nThe `weight` is something like a score - the higher, the better.\nAnd the `matchedParts` are the ranges of the string that match the search query. Note that we are using an array of ranges not just one range, because there can be a few characters in between the matched characters. Here is an illustration:  \n\n<figure>\n  <img class="rounded-corners" src="https://github.com/activcoding/codeedit.app/assets/806104/6e1ee7d3-4c63-4c15-9f45-15cbe0933708" />\n  <figcaption>Search results: \'conviw\' query returns ContentView with the highest relevance.</figcaption>\n</figure>\n\nSecondly we need to make sure that the data we searching within is case- and accent-insensitive. This is commonly referred to as \'normalising the string\'. To achieve this, we need to add two structs:\n\n```swift\nstruct FuzzySearchCharacter {\n    let content: String\n    let normalisedContent: String\n}\n```\n\nAnd\n\n```swift\nstruct FuzzySearchString {\n    var characters: [FuzzySearchCharacter]\n}\n```\n\nThe first one represents one character, the `content` field holds the original character, while `normalisedContent` steps in as its case- and accent-insensitive counterpart.\n\nAnd the FuzzySearchString represents a whole word, essentially an array of characters. Here is a representation of the frensh word summer: "\xe9t\xe9":\n\n<figure>\n  <img class="rounded-corners" src="https://github.com/activcoding/codeedit.app/assets/806104/4fecb94f-f2b5-4a83-948a-84f12feddafc" />\n  <figcaption>Representation of the word \'\xe9t\xe9\' with normalized characters</figcaption>\n</figure>\n\n## Normalise Words\n\nIn order to normalise words, we can create an extension for Strings. Create a new file called: `String+Normalise.swift`. This naming convention enables others to quickly understand the purpose of the file.\n\nWithin the file, you\'ll need to create an extension for String to use the functionality later.\n\n```swift\nextension String {\n    func normalise() -> [FuzzySearchCharacter] {\n        return self.lowercased().map { char in\n	    guard let data = String(char).data(using: .ascii, allowLossyConversion: true), let normalisedCharacter = String(data: data, encoding: .ascii) else {\n	        return FuzzySearchCharacter(content: String(char), normalisedContent: String(char))\n            }\n\n	    return FuzzySearchCharacter(content: String(char), normalisedContent: normalisedCharacter)\n    	}\n    }\n}\n```\n\nIn this function, the String it\'s called on, is first converted to lowercase. Then, it will convert it to data using the ascii encoding and allow lossy conversion, which means that we lose data. Through losing data, we make the String accent-insensitive.\nThe function then returns an array of `FuzzySearchCharacter` objects, representing the original and normalised content for each character.\n\n### Matching Prefix\n\nNow we need to find out if the search query and the string we\'re comparing it against match. To achieve this, we can write another extension: `hasPrefix`. For better understanding, let\'s look at the illustration:\n\n<figure>\n  <img class="rounded-corners" src="https://github.com/activcoding/codeedit.app/assets/806104/f96a4e4f-8821-4989-a744-266cc47b8e8e" />\n  <figcaption>Depicts iterations checking prefixes for a match.</figcaption>\n</figure>\n\nThe function simply checks for matching characters from a specified starting index. This functionality will prove useful in later.\n\n```swift\nextension String {\n    func hasPrefix(prefix: FuzzySearchCharacter, startingAt index: Int) -> Int? {\n        guard let stringIndex = self.index(self.startIndex, offsetBy: index, limitedBy: self.endIndex) else {\n            return nil\n        }\n        let searchString = self.sufflix(from: stringIndex)\n        for prefix in [prefix.content, prefix.normalisedContent] where searchString.hasPrefix(prefix) {\n            return prefix.count\n        }\n        return nil\n    }\n}\n```\n\nLet\'s go through the code step by step:\n\n1. We accept a prefix that is of type `FuzzySearchCharacter`, this is the data against which we test our search \nquery. And we need a starting index.  \n2. Verify if the provided index is valid for the search query.  \n3. Clip the search query (`self`) to start from the provided starting index.  \n4. Iterate through the provided data and check if the prefixes are matching.  \n5. If no match is found, return `nil`.  \n\nIf this function doesn\'t seem clear at the moment, it will become clearer as we use it.\n\n### Fuzzy Searchable Protocol\n\nIn order to make the Fuzzy Search generic, i.e. make it applicable to every data type, we have to write a protocol.\nOther data types can adopt this protocol, enabling them to become fuzzy searchable.\n\n```swift\nprotocol FuzzySearchable {\n    var searchableString: String { get }\n\n    func fuzzyMatch(query: String, characters: FuzzySearchString) -> FuzzySearchMatchResult\n}\n```\n\nIf a data type wants to conform to `FuzzySearchable`, it only needs to add three simple lines. For instance, consider this Model:\n\n```swift\nstruct Books: FuzzySearchable {\n    var title: String\n    var releaseDate: Date\n\n    var searchableString: String {\n        title\n    }\n}\n```\n\nThis approach enables us to use whatever is provided as the searchable string for comparison against the search query.\nAt this point, you might be wondering why the `fuzzyMatch` function is not implemented in the example `Books` struct.\nHowever, we can address this by writing an extension on `FuzzySearchable` that offers a default `fuzzyMatch` function for all data types that adapt to it. This is relatively straightforward compared to other implementations:\n\n```swift\nextension FuzzySearchable {\n    func fuzzyMatch(query: String, characters: FuzzySearchString) -> FuzzySearchMatchResult {\n        [...]\n    }\n}\n```\n\nThis function takes the query, i.e., the search term, and the characters of a word as arguments. The characters represent the string that we compare the search query against. We use `FuzzySearchString` instead of a simple String, because we want a case- and accent-insensitive search.\n\nThe function then returns a `FuzzySearchMatchResult`, which just holds information about the search result, to be precise it includes `let weight: Int` and `let matchedParts: [NSRange]`.\n\nNow let\'s implement the function:\n\n```swift\nextension FuzzySearchable {\n    func fuzzyMatch(query: String, characters: FuzzySearchString) -> FuzzySearchMatchResult {\n        let compareString = characters.characters // the string we compare against\n        let searchString = query.lowercased() // make the query case-insensitive\n\n        var totalScore = 0 // represents the weight of the match\n        var matchedParts = [NSRange]() // Ranges that match compareString and searchString\n\n        // This is always the data for one match\n        var patternIndex = 0\n        var currentScore = 0\n        var currentMatchedPart = NSRange(location: 0, length: 0)\n\n        for (index, character) in compareString.enumerated() {\n            if let prefixLength = searchString.hasPrefix(prefix: character, startingAt: patternIndex) {\n                // A match was found, so we increment the score and the range\n                patternIndex += prefixLength\n                currentScore += 1\n                currentMatchedPart.length += 1\n            } else {\n                // No match was found\n                currentScore = 0\n                if currentMatchedPart.length != 0 {\n                    matchedParts.append(currentMatchedPart)\n                }\n                currentMatchedPart = NSRange(location: index + 1, length: 0)\n            }\n            totalScore += currentScore\n        }\n\n        if currentMatchedPart != 0 {\n            matchedParts.append(currentMatchedPart)\n        }\n\n        if searchString.count == matchedParts.reduce(0, { partialResults, range in \n            range.length + partialResult\n        }) {\n            return FuzzySearchMatchResult(weight: totalScore, matchedParts: matchedParts)\n        } else {\n            return FuzzySearchMatchResult(weight: 0, matchedParts: [])\n        }\n    }\n}\n```\n\nHere is where the magic happens.\n\nFirst of course we extract the compare string from the provided `FuzzySearchString`, then we use a lowercased version of the search query.\n\nWith the necessary preparations in place, we set up our variables to track the matching process. The `totalScore` variable holds the cumulative weight of matches found within an object, while the `matchedParts` variable is an array of ranges representing the specific regions within the object that match the search query.\n\nThe next variables are used for each sub-match in the compareString.\n\n`patternIndex`: This is the starting index of the current sub-match. It is incremented each time a matching character is found.\n\n`currentScore`: This is the score for all sub-matches within the compareString. It is incremented each time a sub-match is found.\n\n`currentMatchedPart`: This is a range that represents one sub-match. It stores the starting and ending indices of the sub-match.\n\nWe now iterate through the compare string using a `for` loop with `.enumerated()` to keep track of the current index. If we find a matching prefix, we can go ahead an increment all values for the current match. The parameters passed to the extension are the characters being compared and the `patternIndex`. It\'s important to use `patternIndex` instead of the index of the `for` loop to avoid double-counting. When a matching prefix is found, we update the `patternIndex` and shift it to the right, i.e. increase it, preventing the same letters from being matched twice. Additionally, we increment the `score` and adjust the `currentMatchedPart` to mark the correct range.\n\nThen we add the `currentScore` to the `totalScore`.\n\nHowever, when the prefixes don\'t align, we reset the `currentScore` to 0. In the scenario where there was a preceding match, indicated by a non-zero length of `currentMatchedPart`, we add the matched range to the `matchedParts`. Subsequently, we reset the `currentMatchedParts` length to 0, while simultaneously shifting the location to the right.\n\nUpon completion of the `for` loop, we check again if the last iteration was still a match and if yes, we append the `currentmatchPart` to the `matchedParts`.\n\nFinally, we make a comparison between the length of the `searchString` and the total length of the found ranges. If these lengths match, we return a `FuzzySearchMatchResult` containing the calculated `totalScore` and the `matchedParts`. However, if the lengths differ, we return a weight of 0 along with an empty array\n\nYou might be wondering whether you need to manually call this function and provide the `FuzzySearchString`. Fortunately, that\'s not necessary. We can just create two concise functions that make the process a bit simpler.\n\n```swift\nfunc normaliseString() -> FuzzySearchString {\n	return FuzzySearchString(characters: searchableString.normalise())\n}\n```\n\nThis function returns the normalised version of the searchableString that is provided by the object that it is called from.\n\n```swift\nfunc fuzzyMatch(query: String) -> FuzzySearchMatchResult {\n    let characters = normaliseString()\n	\n    return fuzzyMatch(query: query, characters: characters)\n}\n```\n\nSubsequently, we simply transform the characters into their normalised counterparts and invoke the fuzzyMatch function. This, in turn, provides us with the `FuzzySearchMatchResult`.\n\n### Fuzzy Search Extension\n\nNow, let\'s make arrays fuzzy-searchable by writing an extension for them. This way, they can easily be searched using our fuzzy match functionality.\n\n```swift\nextension Collection where Iterator.Element: FuzzySearchable {\n    func fuzzySearch(query: String) -> [(result: FuzzySearchmatchResult), item: Iterator.Element)] {\n        return map {\n            (result: $0.fuzzyMatch(query: query), item: $0)\n        }.filter {\n            $0.result.weight > 0\n        }.sorted {\n            $0.result.weight > $1.result.weight\n        }\n    }\n}\n```\n\nTo enable fuzzy searching, we extend Swift\'s `Collection` with a handy `fuzzySearch` method. However, to ensure compatibility, we limit this extension to collections whose elements conform to the `FuzzySearchable` protocol we defined earlier.\n\nWhen using this method, you simply provide a search `query`. The function then iterates over the array, invoking the `fuzzyMatch` method on each element. The `fuzzyMatch` method, as you recall, provides a weight for every element. We leverage these weights to filter out elements with a score less than or equal to 0. Finally, we sort the array, placing the element with the highest score at the top.\n\n*Additionally, for a slight performance boost, consider utilising a `concurrentMap` from the `CollectionConcurrencyKit` package.*\n\n### Usage\n\nIn CodeEdit we for one use the algorithm to provide a quick open overlay that lets user find files quickly. To apply fuzzy search to an array of URLs, you can easily extend the data type `URL` to conform to the `FuzzySearchable` protocol.\n\n```swift\nextension URL: FuzzySearchable {\n    var searchableString: String {\n        return self.lastPathComponent\n    }\n}\n```\n\nIf you\'ve created your custom data type, making it compatible with fuzzy search is a breeze—simply ensure it conforms to the `FuzzySearchable` protocol, as shown here:\n\n```swift\nstruct Users: Identifiable, Codable, FuzzySearchable {\n    var id: Int\n    var name: String\n    var description: String\n \n    var searchableString: String {\n        return name\n    }\n}\n```\n\nAnd now we can just use the fuzzy search function:\n\n```swift\n@State private var searchText: String = ""\nvar users: [Users] = getUsers()\nvar sortedUsers: [Users] {\n    if searchText.isEmpty {\n    	return users\n    } else {\n    	return users.fuzzySearch(query: searchText) map {\n            $0.item\n        }\n    }\n}\n```\n\n## Conclusion\n\nImplementing a fuzzy search algorithm is relatively straightforward, yet it significantly enhances the overall user \nexperience.\n\nIf you prefer to grab the entire code at once, you can find it conveniently shared in this [gist](https://gist.github.com/activcoding/548e093cda10ea323775c78ba689e303). I also have a repository with a few implementations of the fuzzy search algorithm. It includes an option for utilizing fuzzy search with cached data, providing a slight performance boost. Check out the [Demo Repository](https://github.com/activcoding/FuzzySearch-with-SwiftUI) for a closer look. You can also check out the implementation in [CodeEdit](https://github.com/CodeEditApp/CodeEdit).\n\nIf you still have questions, feel free to contact me.  \n\nHappy coding!  \n'}};